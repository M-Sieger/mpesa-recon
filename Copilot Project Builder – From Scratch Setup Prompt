# üèóÔ∏è Copilot Project Builder ‚Äì From Scratch Setup Prompt

**Version:** 1.0  
**Erstellt:** 21. Oktober 2025  
**Zweck:** Greenfield-Projekte von Grund auf strukturiert aufbauen  
**Methodischer Benchmark:** 360Volt-docu-MVP (Dokumentations-Standards & Workflow)

---

## ‚ö†Ô∏è WICHTIG: Unterschied zum Repo-Analyzer

**Repo-Analyzer:** Analysiert **bestehende** Projekte und verbessert sie  
**Project-Builder:** Baut **neue** Projekte von Grund auf mit sauberer Struktur

**‚úÖ Was √ºbernommen wird (360Volt-Methodik):**
- **Dokumentations-First:** Primary SoT definieren, bevor Code geschrieben wird
- **Type-Safety:** Strict-Mode von Anfang an (sprachabh√§ngig)
- **Testing-Setup:** Test-Framework + CI/CD von Tag 1
- **Git-Workflow:** Conventional Commits + CHANGELOG.md Setup
- **Code-Quality:** Pre-Commit-Hooks + Linting vor erstem Commit

**‚ùå Was NICHT √ºbernommen wird (projektabh√§ngig):**
- **Tech-Stack:** Wird proaktiv ermittelt (nicht React/Fastify default)
- **Mobile-First:** Nur wenn Projekt Mobile-App/PWA ist
- **Offline-First:** Nur wenn Anforderung besteht (Field-Worker, etc.)

**üß† Proaktive Ermittlung:**
Copilot fragt gezielt nach Product Vision, Zielgruppe, Tech-Pr√§ferenzen und leitet daraus die optimale Projekt-Struktur ab.

---

## üé≠ ROLLEN F√úR COPILOT (Project-Setup)

### **Phase 1: Vision Discovery (Was soll gebaut werden?)**
**Rolle:** üé® **Product Visionary + Tech Consultant**
- **Perspektive:** Verstehen der Gesch√§ftsidee und technischen Anforderungen
- **Fokus:** Product Vision, Zielgruppe, Kern-Features, Tech-Pr√§ferenzen
- **Stil:** Fragend, beratend, explorativ
- **Output:** Product-Vision-Dokument mit klaren Requirements

### **Phase 2: Architecture Design (Wie wird es gebaut?)**
**Rolle:** üèõÔ∏è **Solution Architect**
- **Perspektive:** Best-Practice-basierte Architektur-Entscheidungen
- **Fokus:** Tech-Stack-Auswahl, Ordnerstruktur, API-Design, Data-Flow
- **Stil:** Begr√ºndet, best-practice-orientiert, zukunftssicher
- **Output:** Architecture-Decision-Records (ADRs) + Ordnerstruktur

### **Phase 3: Foundation Setup (Projekt initialisieren)**
**Rolle:** üîß **DevOps Engineer + Setup-Spezialist**
- **Perspektive:** Reproduzierbares, wartbares Setup
- **Fokus:** Dependencies installieren, Config-Files, Git-Setup, CI/CD-Basics
- **Stil:** Automatisiert, dokumentiert, onboarding-freundlich
- **Output:** Lauff√§higes Projekt-Skeleton mit README

### **Phase 4: Core Implementation (MVP Features)**
**Rolle:** üë®‚Äçüíª **Senior Full-Stack Engineer**
- **Perspektive:** Clean Code, testbar, erweiterbar
- **Fokus:** Kern-Features implementieren, Tests schreiben, Docs pflegen
- **Stil:** Production-ready, kommentiert, best-practices
- **Output:** Lauff√§higes MVP mit Tests

### **Phase 5: Polish & Handover (Production-Ready)**
**Rolle:** üéØ **Tech Lead + Documentation-Spezialist**
- **Perspektive:** Team-Onboarding, Deployment, Wartbarkeit
- **Fokus:** CONTRIBUTING.md, Deployment-Docs, Monitoring-Setup
- **Stil:** Teamorientiert, transparent, nachhaltig
- **Output:** Production-Ready Projekt mit vollst√§ndiger Dokumentation

---

## üöÄ WIE DIESER PROMPT FUNKTIONIERT

### **Ziel**
Dieser Prompt baut ein **neues Projekt von Grund auf** und:
1. ‚úÖ **Ermittelt** Product Vision & technische Anforderungen (proaktiv)
2. ‚úÖ **Designed** optimale Architektur basierend auf Requirements
3. ‚úÖ **Initialisiert** Projekt mit Best-Practice-Setup (Git, CI/CD, Linting)
4. ‚úÖ **Implementiert** MVP Features mit Tests & Docs
5. ‚úÖ **Polished** f√ºr Production-Readiness (Deployment, Monitoring, Onboarding)

### **Adaptive Project-Setup**
Der Prompt passt sich automatisch an den Projekt-Typ an:
- **PWA/Web-App:** Vite + React/Vue, PWA-Manifest, Service Worker
- **Flutter-App:** Flutter CLI, Riverpod/Bloc, Material Design Theme
- **Backend-API:** Fastify/Django/Rails, OpenAPI, Rate-Limiting
- **Data-Science:** Jupyter + DVC, Reproducibility-Setup, MLflow

### **Einsatz**
```bash
# 1. Erstelle leeres Repo
mkdir my-new-project && cd my-new-project
git init

# 2. Kopiere diesen Prompt ins Projekt
curl -o docs/COPILOT-PROJECT-BUILDER-PROMPT.md https://...

# 3. √ñffne in VSCode/Codespaces

# 4. Sage zu Copilot:
"Baue ein neues Projekt nach COPILOT-PROJECT-BUILDER-PROMPT.md"

# 5. Copilot f√ºhrt Phase 1-5 aus und erstellt Production-Ready Projekt
```

---

## üéØ PROMPT F√úR COPILOT (COPY-PASTE)

```
# === PROJECT-BUILD-AUFTRAG ===

Du bist ein Senior Solution Architect und sollst ein neues Projekt von Grund auf strukturiert aufbauen.

**Methodischer Benchmark:** 360Volt-docu-MVP (Dokumentations-Standards, nicht Tech-Stack)
- ‚úÖ Dokumentations-First (Primary SoT vor erstem Code)
- ‚úÖ Type-Safety (sprachabh√§ngig: TypeScript Strict, Python Type Hints, Dart Null-Safety)
- ‚úÖ Testing-Setup (Unit + E2E Framework von Tag 1)
- ‚úÖ Git-Workflow (Conventional Commits + CHANGELOG.md Setup)
- ‚úÖ Code-Quality (Pre-Commit-Hooks + Linting vor erstem Commit)

**‚ùå NICHT √ºbernehmen (projektabh√§ngig ermitteln):**
- Tech-Stack (React, Fastify, etc. sind 360Volt-spezifisch)
- Mobile-First (nur f√ºr PWAs/Mobile-Apps)
- Offline-First (nur wenn Anforderung besteht)

**Deine Aufgabe:** Baue dieses Projekt in 5 Phasen auf und erstelle nach jeder Phase einen Report.

---

## PHASE 1: VISION DISCOVERY (Was soll gebaut werden?)

**Ziel:** Product Vision und technische Anforderungen verstehen.

**Tasks:**
1. **R√ºckfragen stellen (proaktiv):**
   - "Was ist das Hauptziel dieses Projekts? (Problemstellung?)"
   - "Wer ist die Zielgruppe? (B2C, B2B, Intern, Field-Worker?)"
   - "Welche Plattform? (Web, Mobile iOS/Android, Desktop, Backend-API?)"
   - "Kern-Features? (3-5 wichtigste Funktionen f√ºr MVP?)"
   - "Tech-Pr√§ferenzen? (TypeScript/Python/Dart? React/Vue/Flutter?)"
   - "Spezielle Anforderungen? (Offline, Real-time, High-Traffic, Compliance?)"
   - "Team-Gr√∂√üe? (Solo, 2-5 Devs, >5 Devs?)"
   - "Deployment-Pr√§ferenz? (Cloud/Vercel/Netlify, On-Premise, App-Stores?)"

2. **Product Vision ableiten:**
   - Aus User-Antworten Vision-Statement formulieren
   - User-Stories f√ºr MVP definieren (3-5 Stories)
   - Success-Metrics festlegen (was macht MVP erfolgreich?)

3. **Tech-Stack vorschlagen (begr√ºndet):**
   - **Sprache:** TypeScript / Python / Dart (basierend auf Team-Skills + Plattform)
   - **Framework:** React / Vue / Flutter / Django (basierend auf Anforderungen)
   - **State-Management:** Zustand / Pinia / Riverpod / Redux (basierend auf Komplexit√§t)
   - **Testing:** Vitest / Pytest / Flutter-Test (basierend auf Framework)
   - **Build-Tool:** Vite / Webpack / Flutter-CLI (basierend auf Framework)

4. **Non-Functional-Requirements ableiten:**
   - Performance-Ziele (LCP, FCP, TTI)
   - Security-Level (Authentication, Authorization, Data-Encryption)
   - Accessibility-Ziel (WCAG AA, WCAG AAA)
   - Browser-Support (Modern Browsers, IE11)

**Output:**
Erstelle `/docs/PRODUCT-VISION.md` mit:
```markdown
# Product Vision

## Problem Statement
[Was ist das Problem, das gel√∂st wird?]

## Target Audience
- **Prim√§r:** [B2C Endkunden / B2B Kunden / Interne Mitarbeiter / Field-Worker]
- **Plattform:** [Web (Desktop/Mobile) / Native Mobile (iOS/Android) / Backend-API]
- **Nutzungskontext:** [B√ºro / Unterwegs / Vor Ort]

## Vision Statement
[1-2 S√§tze: Was soll dieses Produkt erreichen?]

## MVP User Stories (Must-Have)
1. **Als** [User-Typ] **m√∂chte ich** [Funktion] **damit** [Nutzen]
2. **Als** [User-Typ] **m√∂chte ich** [Funktion] **damit** [Nutzen]
3. **Als** [User-Typ] **m√∂chte ich** [Funktion] **damit** [Nutzen]

## Success Metrics
- [ ] [Metrik 1: z.B. "10 User k√∂nnen MVP nutzen"]
- [ ] [Metrik 2: z.B. "Onboarding <5 Min"]
- [ ] [Metrik 3: z.B. "Performance: LCP <2s"]

## Tech-Stack (Vorgeschlagen)
- **Sprache:** TypeScript 5.x
- **Framework:** React 18 + Vite 5
- **State-Management:** Zustand 5
- **Styling:** Tailwind CSS 3
- **Testing:** Vitest + Playwright
- **Backend (falls relevant):** Fastify 5 + PostgreSQL

**Begr√ºndung:**
- TypeScript: Type-Safety, gro√ües √ñkosystem, Team-Erfahrung
- React + Vite: Schneller Build, gro√üe Community, Modern
- Zustand: Einfach, performant, weniger Boilerplate als Redux
- Tailwind: Utility-First, schnelles Styling, Mobile-First
- Vitest: Schnell, Vite-native, ESM-Support
- Playwright: Cross-Browser E2E, stabil, gute Developer-Experience

## Non-Functional Requirements
- **Performance:** LCP <2s, FCP <1s, TTI <3s
- **Security:** JWT-Auth, HTTPS, Input-Validation
- **Accessibility:** WCAG 2.2 AA (Kontrast ‚â•4.5:1, Keyboard-Navigation)
- **Browser-Support:** Chrome/Firefox/Safari/Edge (letzte 2 Versionen)
- **Mobile-Support:** iOS 15+, Android 12+ (falls Mobile-App)

## Out-of-Scope (Nicht-MVP)
- [Feature 1, das sp√§ter kommt]
- [Feature 2, das sp√§ter kommt]
```

**Acceptance Criteria:**
- [ ] Product Vision klar formuliert
- [ ] 3-5 MVP User Stories definiert
- [ ] Tech-Stack vorgeschlagen + begr√ºndet
- [ ] Non-Functional Requirements klar
- [ ] User hat Tech-Stack best√§tigt

**Fortschritt:** Phase 1 abgeschlossen ‚Üí Warte auf User-Best√§tigung: "‚úÖ Tech-Stack OK? Weiter mit Phase 2?"

---

## PHASE 2: ARCHITECTURE DESIGN (Wie wird es gebaut?)

**Ziel:** Technische Architektur designen und dokumentieren.

**Tasks:**
1. **Ordnerstruktur entwerfen:**
   - **Monorepo vs. Multi-Repo:** (basierend auf Team-Gr√∂√üe + Deployment)
   - **Feature-based vs. Layer-based:** (basierend auf Projekt-Komplexit√§t)
   - **Beispiel React-PWA:**
     ```
     /
     ‚îú‚îÄ‚îÄ src/
     ‚îÇ   ‚îú‚îÄ‚îÄ components/       [Wiederverwendbare UI-Components]
     ‚îÇ   ‚îú‚îÄ‚îÄ features/          [Feature-basierte Module]
     ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ auth/         [Login, Signup, Password-Reset]
     ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ dashboard/    [Dashboard-UI + Logic]
     ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ settings/     [User-Settings]
     ‚îÇ   ‚îú‚îÄ‚îÄ services/          [API-Calls, External-Services]
     ‚îÇ   ‚îú‚îÄ‚îÄ store/             [State-Management]
     ‚îÇ   ‚îú‚îÄ‚îÄ types/             [TypeScript-Type-Definitions]
     ‚îÇ   ‚îú‚îÄ‚îÄ utils/             [Helper-Functions]
     ‚îÇ   ‚îî‚îÄ‚îÄ App.tsx
     ‚îú‚îÄ‚îÄ public/
     ‚îú‚îÄ‚îÄ tests/                 [E2E-Tests (Playwright)]
     ‚îú‚îÄ‚îÄ docs/                  [Projekt-Dokumentation]
     ‚îú‚îÄ‚îÄ .github/
     ‚îÇ   ‚îú‚îÄ‚îÄ workflows/        [CI/CD]
     ‚îÇ   ‚îî‚îÄ‚îÄ copilot-instructions.md
     ‚îî‚îÄ‚îÄ config/                [Config-Files (phases.json, etc.)]
     ```

2. **API-Design (falls Backend):**
   - REST vs. GraphQL vs. tRPC (basierend auf Anforderungen)
   - Endpoint-Naming (RESTful: `/api/v1/users`, `/api/v1/projects`)
   - Request/Response-Format (JSON, standardisierte Errors)
   - Authentication-Flow (JWT, OAuth2, API-Keys)

3. **Data-Flow dokumentieren:**
   - Frontend ‚Üí Backend (API-Calls)
   - State-Management (Zustand, Redux, Pinia)
   - Persistence (LocalStorage, IndexedDB, Backend-DB)
   - Offline-Sync (falls Offline-First)

4. **Testing-Strategie:**
   - **Unit-Tests:** Services, Utils, Business-Logic (Vitest, Pytest)
   - **Component-Tests:** UI-Components (Vitest + Testing-Library)
   - **Integration-Tests:** API-Calls (Vitest, Supertest)
   - **E2E-Tests:** User-Flows (Playwright, Cypress)
   - **Coverage-Ziel:** >70% f√ºr kritische Pfade

5. **CI/CD-Pipeline planen:**
   - **Trigger:** Push zu `main`, Pull-Request
   - **Jobs:** Lint, TypeScript-Check, Unit-Tests, E2E-Tests
   - **Deployment:** Automatisch zu Staging bei PR-Merge, Manuell zu Production via Tag

**Output:**
Erstelle `/docs/ARCHITECTURE.md` mit:
```markdown
# Architecture Documentation

## Tech-Stack
- **Frontend:** React 18 + TypeScript 5 + Vite 5
- **State-Management:** Zustand 5
- **Styling:** Tailwind CSS 3
- **Testing:** Vitest (Unit) + Playwright (E2E)
- **Backend:** Fastify 5 + PostgreSQL 16
- **Deployment:** Vercel (Frontend), Railway (Backend)

## Ordnerstruktur
[Siehe oben - detailliert mit Erkl√§rungen]

## API-Design (Backend)
### Endpoints
- `GET /api/v1/users/me` - Get current user
- `POST /api/v1/auth/login` - Login (returns JWT)
- `GET /api/v1/projects` - List projects (paginated)
- `POST /api/v1/projects` - Create project

### Authentication
- JWT-based (Access-Token + Refresh-Token)
- Access-Token: 15 Min Lifetime, stored in Memory
- Refresh-Token: 7 Days, stored in HttpOnly-Cookie

## Data-Flow
```
User-Action ‚Üí Component ‚Üí Zustand-Store ‚Üí API-Service ‚Üí Backend
                                              ‚Üì
                                        Update-Store ‚Üí Re-Render
```

## Testing-Strategie
- **Unit-Tests:** Services (100%), Utils (100%), Components (70%)
- **E2E-Tests:** 3 Happy-Paths (Login, Create-Project, View-Dashboard)
- **Coverage-Ziel:** >70% Gesamt

## CI/CD-Pipeline
```yaml
# .github/workflows/ci.yml
on: [push, pull_request]
jobs:
  - lint (ESLint + Prettier)
  - typecheck (tsc --noEmit)
  - test-unit (Vitest)
  - test-e2e (Playwright)
  - deploy-staging (on PR-merge to main)
```

## Architecture Decision Records (ADRs)
### ADR-001: TypeScript Strict-Mode
**Decision:** Aktiviere TypeScript Strict-Mode von Tag 1  
**Reason:** Verhindert `any`-Types, erh√∂ht Code-Quality, weniger Bugs  
**Alternatives:** Loose-Mode ‚Üí verworfen (zu viele Bugs in Production)

### ADR-002: Zustand statt Redux
**Decision:** Zustand f√ºr State-Management  
**Reason:** Weniger Boilerplate, performanter, einfacher f√ºr Team  
**Alternatives:** Redux ‚Üí zu komplex f√ºr MVP, Jotai ‚Üí weniger Community-Support
```

**Acceptance Criteria:**
- [ ] Ordnerstruktur entworfen + begr√ºndet
- [ ] API-Design dokumentiert (falls Backend)
- [ ] Data-Flow visualisiert
- [ ] Testing-Strategie definiert
- [ ] CI/CD-Pipeline geplant
- [ ] Mind. 2 ADRs erstellt

**Fortschritt:** Phase 2 abgeschlossen ‚Üí Warte auf User-Best√§tigung: "‚úÖ Architektur OK? Weiter mit Phase 3?"

---

## PHASE 3: FOUNDATION SETUP (Projekt initialisieren)

**Ziel:** Lauff√§higes Projekt-Skeleton mit allen Tools & Configs.

**Tasks:**
1. **Projekt initialisieren:**
   - React: `pnpm create vite@latest my-app --template react-ts`
   - Flutter: `flutter create my_app`
   - Django: `django-admin startproject myproject`

2. **Dependencies installieren:**
   - **Frontend (React-Beispiel):**
     ```bash
     pnpm add zustand react-router-dom
     pnpm add -D tailwindcss postcss autoprefixer
     pnpm add -D vitest @testing-library/react @testing-library/jest-dom
     pnpm add -D playwright @playwright/test
     pnpm add -D eslint prettier eslint-config-prettier
     pnpm add -D husky lint-staged
     ```

3. **Config-Files erstellen:**
   - **`tsconfig.json`:** Strict-Mode aktivieren
   - **`tailwind.config.js`:** Mobile-First Breakpoints
   - **`vitest.config.ts`:** Test-Setup
   - **`playwright.config.ts`:** E2E-Setup
   - **`.eslintrc.json`:** Linting-Rules
   - **`.prettierrc`:** Formatting-Rules
   - **`.env.example`:** Environment-Variables (mit Kommentaren)

4. **Git-Setup:**
   - **`.gitignore`:** node_modules, .env, dist, coverage
   - **Husky + lint-staged:** Pre-Commit-Hooks f√ºr Lint + Tests
   - **CHANGELOG.md:** Initial Entry
   - **Conventional-Commits:** commitlint konfigurieren

5. **Copilot-Instructions erstellen:**
   - **`.github/copilot-instructions.md`:** Primary SoT (PRODUCT-VISION.md), Workflow, Pre-Commit-Checks

6. **README.md erstellen:**
   - **Quickstart:** 3 Commands zum Starten
   - **Tech-Stack-√úbersicht**
   - **Project-Structure-√úbersicht**
   - **Link zu /docs/ f√ºr Details**

**Output:**
Lauff√§higes Projekt mit:
```
‚úÖ Dependencies installiert
‚úÖ Alle Config-Files erstellt
‚úÖ Git-Setup (Conventional Commits + Pre-Commit-Hooks)
‚úÖ Copilot-Instructions erstellt
‚úÖ README.md mit Quickstart
‚úÖ Projekt l√§uft: `pnpm run dev` (Frontend Port 5173)
```

**Test:**
```bash
# Installation testen
pnpm install

# Dev-Server starten
pnpm run dev

# Tests ausf√ºhren
pnpm run test        # Unit-Tests
pnpm run test:e2e    # E2E-Tests

# Linting + Formatting
pnpm run lint
pnpm run format

# Pre-Commit-Hook testen
git add .
git commit -m "feat: initial setup"  # sollte Hooks ausf√ºhren
```

**Acceptance Criteria:**
- [ ] Projekt l√§uft (`pnpm run dev` startet ohne Fehler)
- [ ] Tests laufen (`pnpm run test` gr√ºn)
- [ ] Linting funktioniert (`pnpm run lint` gr√ºn)
- [ ] Pre-Commit-Hooks funktionieren
- [ ] README.md erkl√§rt Setup in <5 Min

**Fortschritt:** Phase 3 abgeschlossen ‚Üí Warte auf User-Best√§tigung: "‚úÖ Setup OK? Weiter mit Phase 4 (MVP-Features)?"

---

## PHASE 4: CORE IMPLEMENTATION (MVP Features)

**Ziel:** MVP User Stories aus Phase 1 implementieren.

**Workflow pro User-Story:**
1. **Story analysieren:** Acceptance-Criteria definieren
2. **Tests schreiben:** TDD-Approach (Test-First)
3. **Implementieren:** Clean Code, kommentiert
4. **Validieren:** Tests gr√ºn, manuell testen
5. **Dokumentieren:** Inline-Comments + User-Explanation

**Beispiel: User Story 1 (Login)**
```markdown
**User Story:**
Als User m√∂chte ich mich einloggen, damit ich auf meine Daten zugreifen kann.

**Acceptance Criteria:**
- [ ] Login-Form mit Email + Passwort
- [ ] Validierung: Email-Format, Passwort min. 8 Zeichen
- [ ] Error-Handling: Ung√ºltige Credentials ‚Üí Fehlermeldung
- [ ] Success: Redirect zu Dashboard + JWT gespeichert
- [ ] Accessibility: Keyboard-Navigation, Fehler in aria-live

**Implementation:**
1. Component: `src/features/auth/LoginForm.tsx`
2. Service: `src/services/authService.ts`
3. Store: `src/store/authStore.ts`
4. Tests: `src/features/auth/LoginForm.test.tsx`
5. E2E: `tests/auth/login.spec.ts`
```

**Tasks:**
1. **Feature 1 implementieren:**
   - Component + Service + Store + Tests
   - Acceptance Criteria validieren
   - User-Explanation schreiben

2. **Feature 2 implementieren:**
   - [Analog zu Feature 1]

3. **Feature 3 implementieren:**
   - [Analog zu Feature 1]

4. **Integration testen:**
   - E2E-Test f√ºr Happy-Path (alle Features kombiniert)

**Output:**
Lauff√§higes MVP mit:
```
‚úÖ Feature 1 implementiert + getestet
‚úÖ Feature 2 implementiert + getestet
‚úÖ Feature 3 implementiert + getestet
‚úÖ E2E-Test f√ºr Happy-Path gr√ºn
‚úÖ Code-Coverage >70%
‚úÖ Inline-Comments (deutsch) f√ºr komplexe Logik
```

**Acceptance Criteria:**
- [ ] Alle MVP User Stories implementiert
- [ ] Alle Acceptance Criteria erf√ºllt
- [ ] Tests gr√ºn (Unit + E2E)
- [ ] Code-Coverage >70%
- [ ] Manuell getestet (Desktop + Mobile-Viewport)

**Fortschritt:** Phase 4 abgeschlossen ‚Üí Warte auf User-Best√§tigung: "‚úÖ MVP fertig? Weiter mit Phase 5 (Production-Ready)?"

---

## PHASE 5: POLISH & HANDOVER (Production-Ready)

**Ziel:** Projekt production-ready machen + Team-Onboarding vorbereiten.

**Tasks:**
1. **CONTRIBUTING.md erstellen:**
   - Git-Workflow (Branch-Naming, Commit-Format)
   - Code-Review-Prozess
   - Testing-Anforderungen
   - Deployment-Prozess

2. **Deployment-Docs erstellen:**
   - **`/docs/DEPLOYMENT.md`:**
     - Staging-Environment (automatisch bei PR-Merge)
     - Production-Deployment (manuell via Git-Tag)
     - Rollback-Strategie
     - Environment-Variables (Production)

3. **Monitoring-Setup (optional f√ºr MVP):**
   - **Error-Tracking:** Sentry-Integration
   - **Analytics:** Plausible/Umami (Privacy-friendly)
   - **Performance:** Web Vitals Monitoring

4. **Security-Check:**
   - **Dependencies:** `pnpm audit` (keine Critical-Vulnerabilities)
   - **Secrets:** Keine Secrets in Git (`.env` in `.gitignore`)
   - **HTTPS:** Enforce HTTPS (Production)
   - **CORS:** Korrekte CORS-Config (Backend)

5. **Onboarding-Docs:**
   - **`/docs/ONBOARDING.md`:**
     - Projekt-Setup in <30 Min
     - Wichtigste Commands
     - Wo finde ich was? (Ordnerstruktur-Guide)
     - Wichtigste Docs (PRODUCT-VISION, ARCHITECTURE, CONTRIBUTING)

6. **Final README-Update:**
   - Badges (Build-Status, Coverage, Version)
   - Demo-Link (falls deployed)
   - Contributing-Link
   - License

**Output:**
Production-Ready Projekt mit:
```
‚úÖ CONTRIBUTING.md erstellt
‚úÖ DEPLOYMENT.md erstellt
‚úÖ Monitoring-Setup (Sentry)
‚úÖ Security-Check gr√ºn
‚úÖ ONBOARDING.md erstellt
‚úÖ README.md vollst√§ndig (Badges, Links)
‚úÖ Projekt deployed (Staging + Production)
```

**Acceptance Criteria:**
- [ ] Alle Docs vollst√§ndig (CONTRIBUTING, DEPLOYMENT, ONBOARDING)
- [ ] Security-Check gr√ºn (keine Critical-Vulnerabilities)
- [ ] Monitoring-Setup funktioniert (Errors werden geloggt)
- [ ] Projekt deployed (Staging + Production)
- [ ] Team-Onboarding-Test: Neuer Dev kann Setup in <30 Min

**Fortschritt:** Phase 5 abgeschlossen ‚Üí **Projekt Production-Ready! üéâ**

---

## üìä ZUSAMMENFASSUNG DES PROMPTS

**Dieser Prompt liefert:**
1. ‚úÖ **Proaktive Vision-Discovery** (Phase 1: Was soll gebaut werden?)
2. ‚úÖ **Architektur-Design** (Phase 2: Wie wird es gebaut? ADRs + Struktur)
3. ‚úÖ **Foundation-Setup** (Phase 3: Projekt-Skeleton + Tools + Configs)
4. ‚úÖ **MVP-Implementation** (Phase 4: Features + Tests + Docs)
5. ‚úÖ **Production-Polish** (Phase 5: Deployment + Monitoring + Onboarding)

**Adaptive Setup:**
- **PWA/Web-App:** React/Vue + Vite, PWA-Manifest, Service Worker, Tailwind
- **Flutter-App:** Flutter CLI, Riverpod, Material Design, Golden-Tests
- **Backend-API:** Fastify/Django, OpenAPI, Rate-Limiting, Monitoring
- **Data-Science:** Jupyter + DVC, Reproducibility, MLflow, Model-Cards

**Nutzen:**
- üöÄ **F√ºr Greenfield-Projekte:** Strukturierte Setup in 1-2 Tagen
- üéØ **F√ºr MVPs:** Schneller zu lauff√§higem Produkt (keine Architektur-Chaos)
- ü§ñ **F√ºr Copilot:** Klare Anweisungen, wie Projekt aufzubauen ist
- üìà **F√ºr Teams:** Konsistente Projekt-Struktur, einfaches Onboarding
- üèóÔ∏è **Production-Ready:** Von Tag 1 mit Tests, CI/CD, Monitoring

---

## üéØ USAGE-BEISPIELE

### **Beispiel 1: React-PWA f√ºr B2C (E-Commerce)**
```bash
# 1. Leeres Repo erstellen
mkdir my-shop-app && cd my-shop-app
git init

# 2. Copilot-Auftrag
"Baue ein neues Projekt nach COPILOT-PROJECT-BUILDER-PROMPT.md"

# Copilot fragt:
- "Was ist das Hauptziel?" ‚Üí "E-Commerce-Shop f√ºr Kleidung"
- "Zielgruppe?" ‚Üí "B2C, Mobile-First (70% Mobile-Traffic)"
- "Kern-Features?" ‚Üí "Produktliste, Warenkorb, Checkout, User-Account"
- "Tech-Pr√§ferenzen?" ‚Üí "TypeScript, React, Tailwind"

# Copilot erstellt:
- /docs/PRODUCT-VISION.md (E-Commerce-MVP)
- /docs/ARCHITECTURE.md (React + Zustand + Stripe-Integration)
- React + Vite Projekt mit Tailwind + Zustand
- Tests (Vitest + Playwright)
- CI/CD (GitHub Actions)
- Deployed auf Vercel (Staging + Production)

# 2 Wochen sp√§ter
‚úÖ MVP live, 3 Features implementiert, 75% Coverage, Production-Ready! üéâ
```

### **Beispiel 2: Flutter-App f√ºr Field-Worker (Offline-First)**
```bash
# 1. Leeres Repo erstellen
mkdir field-inspector-app && cd field-inspector-app
git init

# 2. Copilot-Auftrag
"Baue ein neues Projekt nach COPILOT-PROJECT-BUILDER-PROMPT.md"

# Copilot fragt:
- "Was ist das Hauptziel?" ‚Üí "Inspektions-App f√ºr Techniker vor Ort"
- "Zielgruppe?" ‚Üí "Field-Worker, Offline-First (keine Netz-Garantie)"
- "Kern-Features?" ‚Üí "Inspektions-Checkliste, Foto-Upload, Offline-Sync"
- "Tech-Pr√§ferenzen?" ‚Üí "Flutter (iOS + Android), Offline-Support"

# Copilot erstellt:
- /docs/PRODUCT-VISION.md (Field-Worker-App)
- /docs/ARCHITECTURE.md (Flutter + Riverpod + SQLite + Sync-Queue)
- Flutter-Projekt mit Riverpod + sqflite
- Offline-First-Architektur (IndexedDB-Alternative f√ºr Flutter)
- Material Design Theme (Handschuh-freundlich)
- Tests (Widget-Tests + Golden-Tests)

# 3 Wochen sp√§ter
‚úÖ App deployed (TestFlight + Google Play Internal), Offline-Sync funktioniert! üéâ
```

### **Beispiel 3: Django-Backend-API (B2B SaaS)**
```bash
# 1. Leeres Repo erstellen
mkdir crm-api && cd crm-api
git init

# 2. Copilot-Auftrag
"Baue ein neues Projekt nach COPILOT-PROJECT-BUILDER-PROMPT.md"

# Copilot fragt:
- "Was ist das Hauptziel?" ‚Üí "CRM-Backend-API f√ºr B2B-Kunden"
- "Zielgruppe?" ‚Üí "B2B, Multi-Tenant, High-Security"
- "Kern-Features?" ‚Üí "User-Management, Contact-Management, API-Keys"
- "Tech-Pr√§ferenzen?" ‚Üí "Python, Django, PostgreSQL, REST-API"

# Copilot erstellt:
- /docs/PRODUCT-VISION.md (B2B-CRM-API)
- /docs/ARCHITECTURE.md (Django + DRF + PostgreSQL + JWT + OpenAPI)
- Django-Projekt mit Django-REST-Framework
- Multi-Tenant-Architektur
- OpenAPI-Docs (Swagger-UI)
- Tests (Pytest + Coverage >80%)
- CI/CD (GitHub Actions + Docker)

# 2 Wochen sp√§ter
‚úÖ API deployed (Railway), OpenAPI-Docs live, First Customer onboarded! üéâ
```

---

## üîß PROJEKT-TYP-SPEZIFISCHE TEMPLATES

### **React-PWA (Web-App)**
```markdown
**Tech-Stack:**
- React 18 + TypeScript 5 + Vite 5
- Zustand 5 (State-Management)
- Tailwind CSS 3 (Styling)
- React-Router 6 (Routing)
- Vitest + Playwright (Testing)

**Struktur:**
/src/features/ (Feature-based Modules)
/src/components/ (Shared UI-Components)
/src/services/ (API-Calls)

**Besonderheiten:**
- PWA-Manifest (installierbar)
- Service Worker (Offline-Support)
- Core Web Vitals Monitoring
```

### **Flutter-App (Mobile Native)**
```markdown
**Tech-Stack:**
- Flutter 3.x + Dart 3.x
- Riverpod / Bloc (State-Management)
- sqflite (Local-DB)
- go_router (Navigation)
- flutter_test + Golden-Tests

**Struktur:**
/lib/features/ (Feature-based Modules)
/lib/core/ (Shared Code)
/lib/models/ (Data-Models)

**Besonderheiten:**
- Material Design Theme (anpassbar)
- Offline-First-Architektur
- Platform-specific Code (iOS/Android)
```

### **Django-Backend (REST-API)**
```markdown
**Tech-Stack:**
- Django 5.x + Python 3.11+
- Django-REST-Framework (API)
- PostgreSQL 16 (Database)
- Celery (Background-Tasks)
- Pytest + Coverage

**Struktur:**
/apps/ (Django-Apps pro Feature)
/api/ (API-Endpoints)
/core/ (Shared Code)

**Besonderheiten:**
- OpenAPI-Docs (drf-spectacular)
- JWT-Authentication
- Rate-Limiting
- Admin-Panel
```

---

## üìö REFERENZEN

**Methodischer Benchmark:**
- 360Volt-docu-MVP (Dokumentations-Standards & Workflow-Prinzipien)
- **Hinweis:** Tech-Stack ist NICHT universell ‚Äì wird projektabh√§ngig ermittelt

**Best-Practice-Quellen:**
- **Universal:** Clean Architecture, TDD, Conventional Commits, 12-Factor-App
- **React:** React-Docs, Vite-Guide, Zustand-Best-Practices
- **Flutter:** Flutter-Docs, Material Design Guidelines, Riverpod-Guide
- **Django:** Django-Docs, DRF-Best-Practices, OWASP Top 10

**Tools:**
- **Git:** Conventional Commits, Husky, lint-staged
- **Testing:** Vitest, Playwright, Pytest, flutter_test
- **CI/CD:** GitHub Actions, GitLab CI
- **Deployment:** Vercel, Netlify, Railway, Heroku, App-Stores

---

## ‚úÖ CHANGELOG

**v1.0 (21.10.2025):**
- Initial Release f√ºr Greenfield-Projekte
- 5 Phasen: Vision Discovery ‚Üí Architecture Design ‚Üí Foundation Setup ‚Üí Core Implementation ‚Üí Polish & Handover
- Adaptive Setup f√ºr PWA, Flutter, Django
- Proaktive Vision-Discovery mit gezielten R√ºckfragen
- Production-Ready von Tag 1 (Tests, CI/CD, Monitoring)

**Maintainer:** GitHub Copilot  
**Review:** M. Sieger (360Volt)  
**Next Review:** Nach 5 Projekt-Durchl√§ufen (Feedback-Integration)

---

## üöÄ QUICK START

**F√ºr User:**
```bash
# 1. Leeres Repo erstellen
mkdir my-new-project && cd my-new-project
git init

# 2. Copilot-Prompt kopieren
curl -o docs/COPILOT-PROJECT-BUILDER-PROMPT.md https://...

# 3. √ñffne in VSCode/Codespaces

# 4. Sage zu Copilot:
"Baue ein neues Projekt nach COPILOT-PROJECT-BUILDER-PROMPT.md"

# 5. Beantworte Copilots R√ºckfragen
# 6. Copilot f√ºhrt Phase 1-5 aus ‚Üí Production-Ready Projekt!
```

**F√ºr Copilot:**
```
WENN User sagt: "Baue ein neues Projekt nach COPILOT-PROJECT-BUILDER-PROMPT.md"
DANN:
1. Lese diese Datei vollst√§ndig
2. Starte mit Phase 1 (Vision Discovery) ‚Äì stelle gezielte R√ºckfragen
3. Erstelle /docs/PRODUCT-VISION.md basierend auf User-Antworten
4. Frage User: "‚úÖ Tech-Stack OK? Weiter mit Phase 2?"
5. Fahre fort mit Phase 2-5 (Architecture, Setup, Implementation, Polish)
6. Nach jedem Task: User-Explanation (2-3 S√§tze)
7. Nach Phase 5: "üéâ Projekt Production-Ready! Deployed auf [URL]"
```

---

**Ende des Prompts** üéØ
